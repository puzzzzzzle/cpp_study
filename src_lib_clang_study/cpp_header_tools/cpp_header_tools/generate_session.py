from cpp_header_tools.utils.exceptions import GeneratedException
import logging

logger = logging.getLogger(__name__)


class GeneratedItem:
    def __init__(self, macro_name, generated_code):
        self.macro_name = macro_name
        self.generated_code: str = generated_code
        self.other_info = {}
        pass

    pass


class GenerateSession:
    def __init__(self, analyzer, relations, header_path: str, cpp_path: str = None):
        self.analyzer = analyzer
        self.relations = relations
        self.writer_target_dir = {"generated.h": header_path, "generated.cpp": cpp_path}

        # generated for curr file
        self.generated = {}
        self.generated_inner_class = []

        # global shared generated
        self.shared_generated_files = {}
        self._init_header_cpp()

        pass

    def _init_header_cpp(self):
        self.get_generated_header().append(GeneratedItem(
            "",
            R"""
// generated by cpp header tools
// do not edit it
#pragma once
                    """))
        self.get_generated_cpp().append(GeneratedItem(
            "",
            fR"""
// generated by cpp header tools
// do not edit it
#include "{self.analyzer.header_inc.spelling}"
            """
        ))
    def set_out_type_dir(self, file_type, path):
        self.writer_target_dir[file_type] = path
        return self

    def get_generated_info(self, file_type):
        if file_type not in self.generated:
            self.generated[file_type]: [GeneratedItem] = []
        return self.generated[file_type]

    def get_generated_inner_class(self):
        return self.generated_inner_class

    def get_generated_header(self) -> [GeneratedItem]:
        return self.get_generated_info("generated.h")

    def get_generated_cpp(self):
        return self.get_generated_info("generated.cpp")

    def set_global_shared(self, file_name, content):
        assert file_name not in self.shared_generated_files
        self.shared_generated_files[file_name] = content

    def write_type(self, file_type):
        target_dir = self.writer_target_dir.get(file_type, None)
        if target_dir is None:
            logger.debug(f"target type not defined out dir , write to header dir {file_type}")
            target_dir = self.writer_target_dir["generated.h"]
        generated_info = self.generated.get(file_type, None)
        if generated_info is None or len(generated_info) is None:
            logger.debug(f"target type not generated anything {file_type}")
        with open(f"{target_dir}/{self.analyzer.file_name}.{file_type}", "wt") as f:
            item: GeneratedItem
            for item in generated_info:
                if item.macro_name != "":
                    f.write(f"// generated by macro {item.macro_name}\n")
                f.write(item.generated_code)
                f.write("\n")
            if file_type == "generated.h":
                f.write(self._make_generated_inner_class())

        pass

    def _make_generated_inner_class(self):
        item: GeneratedItem
        result = "#undef  CH_GENERATED\n"
        result += "#define CH_GENERATED() \\\n"
        result += "private:\\\n"
        for item in self.generated_inner_class:
            lines = item.generated_code.split("\n")
            for line in lines:
                if line == "":
                    continue
                result += f"{line} \\\n"
        result += "private:\n"
        return result

    def write_all(self):
        for item in self.generated.keys():
            self.write_type(item)
        pass
