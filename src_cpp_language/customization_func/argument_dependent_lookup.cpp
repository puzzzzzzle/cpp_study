//
// Created by khalidzhang on 2022/12/22.
//
#include "common_includes.h"
/*
首先，如果通常的无限定查找所生成的集合含有下列任何内容，那么不考虑实参依赖查找:

1) 类成员的声明
2) 块作用域的（非 using 声明的）函数声明
3)
任何非函数或函数模板的声明（例如函数对象或另一变量，它的名字与正在查找的函数名冲突）
否则，对于每个函数调用表达式中的实参，检验它的类型，以确定它将向查找所添加的命名空间与类的关联集。

1) 对于基础类型的实参，命名空间与类的关联集是空集
2) 对于类类型（含联合体）的实参，集合由以下组成：
a) 该类自身
b) 它所有的直接与间接基类
c) 如果该类是另一类的成员，该外围类
d) 添加到集合的各个类的最内层外围命名空间
3)
对于类型是类模板的特化的实参，在上述关于类的规则外，还检验以下类型，并将与它关联的类与命名空间添加到集合中：
a) 为各类型模板形参提供的所有模板实参的类型（跳过非类型模板形参和模板模板形参）
b) 以任何模板模板实参为其中成员的命名空间
c) 以任何模板模板实参为其中成员的类（如果它们是类成员模板）
4)
对于任何枚举类型的实参，向集合中添加该枚举类型的声明的最内层外围命名空间。如果该枚举类型是类成员，那么向集合中添加该类。
5) 对于 T 的指针或指向 T 的数组的指针类型的实参，检验类型 T
并向集合中添加它的类与命名空间的关联集合。 6)
对于函数类型的实参，检验各函数形参类型与函数返回值类型，并向集合中添加它们的类与命名空间的关联集合。
7) 对于指向类 X 的成员函数 F
的指针类型的实参，检验各函数形参类型、函数返回值类型及类
X，并向集合中添加它们的类与命名空间的关联集合。 8) 对于指向类 X 的数据成员 T
的指针类型的实参，检验该成员类型和类型
X，并向集合添加它们的类与命名空间的关联集合。 9)
如果实参是一组重载函数（或函数模板）的名字或取址表达式，那么检验重载集合中的每个函数，并向集合添加它的类与命名空间的关联集合。
a)
另外，如果以模板标识（带模板实参的模板名）指名重载集，那么检验它的所有类型模板实参与模板模板实参（但不包括非类型模板实参），并向集合添加它的类与命名空间的关联集合。
如果类与命名空间的关联集合中的任何命名空间是内联命名空间，那么向集合中添加它的外围命名空间。

如果类与命名空间的关联集合中的任何命名空间直接含有内联命名空间，那么向集合中添加该内联命名空间。

(C++11 起)
在确定命名空间与类的关联集合后，为了进一步的 ADL
处理，忽略此集中所有在类中找到的声明，但不包括命名空间作用域的友元函数及函数模板，在后述点
2 陈述。

根据下列特殊规则，将通过常规无限定查找所找到的声明的集合，与通过 ADL
所生成的关联集合的所有元素中找到的声明集合进行合并：

1) 忽略关联命名空间中的 using 指令
2) 在关联类中的命名空间作用域声明的友元函数（及函数模板）通过 ADL
可见，即使它们通过普通查找不可见。 3)
忽略除函数与函数模板外的所有名字（不会与变量之间发生冲突）
 */
namespace adl {
namespace view_base {
template <typename T>
void Show(T& v) noexcept {
  LOG_DEBUG("show nothing")
}
}  // namespace view_base

namespace view_impl {
class ImgView {
  friend void Show(ImgView& v) noexcept { LOG_DEBUG("show img") }
};
class VoidView {};
}  // namespace view_impl

TEST(adl, 1) {
  adl::view_impl::VoidView vv{};
  adl::view_impl::ImgView iv{};

  Show(iv);
  //  Show(vv); //error

  view_base::Show(vv);
  view_base::Show(iv);

  using namespace view_base;
  Show(iv);
  Show(vv);
}
}  // namespace adl